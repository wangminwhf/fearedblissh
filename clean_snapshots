#!/usr/bin/env python3

# Copyright 2013-2015 Jonathan Vasquez <jvasquez1011@gmail.com>
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

import sys
import os

from subprocess import call
from subprocess import check_output
from subprocess import CalledProcessError

# Provides utility functions that can be used by any class
class Tools(object):
    @classmethod
    # Runs a command and gets back the output
    def run(cls, cmd):
        return check_output(cmd, shell=True, universal_newlines=True).strip()

    @classmethod
    # Displays a message and quits with an error code of 1
    def die(cls, message):
        print(message)
        quit(1)

    @classmethod
    # Prints usage information
    def print_usage(cls):
        print("Cleans target pool asking for confirmation with a default slice date of 30 days prior to today:")
        print("# clean_snapshots -p <pool> -t zfs \n")
        print("Cleans target pool asking for confirmation with a slice date of <date>:")
        print("# clean_snapshots -p <pool> -t zfs -d <date>\n")
        print("Cleans target pool not asking for confirmation with a default slice date of 30 days prior to today:")
        print("# clean_snapshots -f -p <pool> -t btrfs\n")
        print("Cleans target pool not asking for confirmation with a slice date of <date>:")
        print("# clean_snapshots -f -p <pool> -d <date> -t btrfs\n")

# Provides date managing tools
class DateManager(object):
    @classmethod
    def __init__(cls):
        cls.date_today = cls.get_todays_date()
        cls.date_slice = cls.get_default_date()
        cls.date_slice_year = ""
        cls.date_slice_month = ""
        cls.date_slice_day = ""

    @classmethod
    # Updates the date slices
    def update_date_slices(cls):
        try:
            cls.date_slice_year = cls.get_slice_year()
            cls.date_slice_month = cls.get_slice_month()
            cls.date_slice_day = cls.get_slice_day()
        except IndexError:
            Tools.die("Date must be in <month>_<date>_<year> format! Example: " + cls.date_today)

    @classmethod
    # Gets the year from date_slice
    def get_slice_year(cls):
        return int(cls.date_slice.split("_")[2])

    @classmethod
    # Gets the month from date_slice
    def get_slice_month(cls):
        return int(cls.date_slice.split("_")[0])

    @classmethod
    # Gets the day from date_slice
    def get_slice_day(cls):
        return int(cls.date_slice.split("_")[1])

    @classmethod
    def get_todays_date(cls):
        cmd = 'date +%m_%d_%y'
        return Tools.run(cmd)

    @classmethod
    # Prints the date slices individually
    def print_date_slices(cls):
        print("Slice Month: " + str(cls.date_slice_month))
        print("Slice Day: " + str(cls.date_slice_day))
        print("Slice Year: " + str(cls.date_slice_year))

    @classmethod
    # Returns the default date (30 days before today)
    def get_default_date(cls):
        date_parts = cls.date_today.split("_")

        new_month = int(date_parts[0]) - 1

        if new_month < 10:
            def_date = "0" + str(new_month) + "_" + date_parts[1] + "_" + date_parts[2]
        else:
            def_date = str(new_month) + "_" + date_parts[1] + "_" + date_parts[2]

        return def_date

# The main class
class Cleaner(object):
    def __init__(self):
        # Starts up the DateManager so that the static variables
        # within the class are initialized.
        DateManager()

        # Don't ask for confirmation when deleting snapshots?
        self.force = 0

        # What type of filesystem snapshots will we managing? (zfs or btrfs)
        self.fstype = ""

    # Checks parameters and running user
    def welcome(self):
        user = check_output(["whoami"], universal_newlines=True).strip()

        if user != "root":
            Tools.die("This program must be ran as root")

        arguments = sys.argv[1:]

        # clean_snapshots -f -p <pool> -d <date> -t <fstype>
        # clean_snapshots -f -p tank -d 06_09_14 -t zfs
        if len(arguments) >= 1:
            for i in range(len(arguments)):
                # Sets the force flag
                if arguments[i] == "-f":
                    self.force = 1

                # Sets the type of snapshots we will be cleaning (zfs or btrfs)
                if arguments[i] == "-t":
                    try:
                        self.fstype = arguments[i+1]
                    except IndexError:
                        Tools.die("No filesystem type was passed to -t")

                # Sets the top level dataset name
                elif arguments[i] == "-p":
                    try:
                        self.pool = arguments[i+1]
                    except IndexError:
                        Tools.die("No pool name was passed to -p")

                # Sets the slice date
                elif arguments[i] == "-d":
                    try:
                        DateManager.date_slice = arguments[i+1]
                    except IndexError:
                        Tools.die("No date was passed to -d")

                # Displays the help/usage message
                elif arguments[i] == "-h":
                    Tools.print_usage()
                    quit(0)

            if not self.fstype:
                Tools.die("No filesystem type was specified.")

            if self.fstype == "zfs":
                self.fs_manager = ZfsManager()
            elif self.fstype == "btrfs":
                self.fs_manager = BtrfsManager()
            else:
                Tools.die("The filesystem you've specified is not supported!")

            # Extracts the pool information needed given the filesystem type being used
            self.fs_manager.get_pool_info(self.pool)

            # Updates the time slices immediately, this also serves
            # as a check to see if the user wrote in the date in the
            # correct format: month_date_year
            DateManager.update_date_slices()
        else:
            Tools.print_usage()
            Tools.die("You must pass the pool you want to clean. See the above examples.")

    # Main
    def start(self):
        print("Today's Date : " + DateManager.date_today)
        print("Slice Date   : " + DateManager.date_slice)
        print("Pool         : " + self.fs_manager.pool)
        print("")

        # Retrieves the snapshots in our given pool
        self.fs_manager.get_pool_snapshots()

        # Check each snapshot and if it is older than the slice date,
        # add it to our removal queue.
        self.fs_manager.check_snapshots()

        # Print the snapshots that will be removed
        if self.fs_manager.queue:
            self.fs_manager.print_queue()

            print("Amount of Snapshots to Remove: " + str(self.fs_manager.get_queue_size()))
            print("")

        if self.fs_manager.queue:
            if not self.force:
                choice = input("Do you want to remove the above snapshots? [y/N]: ")
                print("")

                # Remove the snapshots that are in the slicer
                if choice == 'y' or choice == 'Y':
                    self.fs_manager.destroy_snapshots()

                elif choice == 'n' or choice == 'N' or not choice:
                    print("Not removing any snapshots. Exiting.")
                    quit()
                else:
                    Tools.die("Invalid Option. Exiting.")

            # If the force flag was enabled (maybe script mode), then just remove
            # the snapshots without asking for confirmation.
            else:
                self.fs_manager.destroy_snapshots()
        else:
            print("The pool is already clean. Exiting.")

# Provides common functionality between things that cleaning a zfs and btrfs snapshot require.
class FSManager(object):
    def __init__(self):
        # List of snapshots in our given pool
        self.snapshots = []

        # List of snapshots that will be deleted
        self.queue = []

        # Pool
        self.pool = ""

    # Checks all the snapshots in the queue and if older adds them to our deletion queue
    def check_snapshots(self):
        for snap in self.snapshots:
            self.slicer(snap)

    # Removes the target snapshot
    def destroy(self, a_snap, cmd):
        print("Removing: " + a_snap)
        Tools.run(cmd)

    # Remove the snapshots
    def destroy_snapshots(self):
        for snap in self.queue:
            self.destroy(snap)

    # Retrieves all the snapshots for the given pool
    def get_pool_snapshots(self, cmd):
        try:
            results = Tools.run(cmd)

            if results:
                for snap in results.split("\n"):
                    self.snapshots.append(snap)
        except CalledProcessError:
            pass

    # Prints out the snapshots in the given pool
    def print_pool_snapshots(self):
        if self.snapshots:
            for snap in self.snapshots:
                print("Snapshot: " + snap)
        else:
            print("No snapshots available!")

    # Adds a snapshot to our removal queue
    def add_to_queue(self, a_snap):
        self.queue.append(a_snap)

    # Retrieves the snapshot removal queue
    def get_queue(self):
        return self.queue

    # Prints the snapshot removal queue
    def print_queue(self):
        print("Pending Removal: ")
        print("----------------")

        for snap in self.queue:
            print(snap)

        print("")

    # Returns the queue size
    def get_queue_size(self):
        return len(self.queue)

    # Adds a snapshot to our removal list if it passes the slice date
    def slicer(self, a_snap, at_split, date_split):
        month = int(date_split[0])
        day = int(date_split[1])
        year = int(date_split[2])

        if year < DateManager.date_slice_year:
            #print("Snapshot " + a_snap + " is older by at least a year!")
            self.add_to_queue(a_snap)
        elif month < DateManager.date_slice_month:
            #print("Snapshot " + a_snap + " is older by at least a month!")
            self.add_to_queue(a_snap)
        elif month == DateManager.date_slice_month and day <= DateManager.date_slice_day:
            #print("Snapshot " + a_snap + " is older by a few days of the slice date!")
            self.add_to_queue(a_snap)
        #else:
           #print("Snapshot " + a_snap + " is newer than slice date " + DateManager.date_slice + "!")

# Provides zfs specific attributes that is required to clean zfs snapshots
class ZfsManager(FSManager):
    def __init__(self):
        super().__init__()

    def slicer(self, a_snap):
         # Left side = dataset, Right Side = date [0, 1]
        at_split = a_snap.split("@")

        # Splits the right side into month/date/year
        date_split = at_split[1].split("_")

        super().slicer(a_snap, at_split, date_split)

    def destroy(self, a_snap):
        cmd = 'zfs destroy ' + a_snap
        super().destroy(a_snap, cmd)

    def get_pool_info(self, pool):
        self.pool = pool

    # Retrieves all the snapshots for the given pool
    def get_pool_snapshots(self):
        cmd = 'zfs list -t snapshot -H -o name -s name | grep ' + self.pool
        super().get_pool_snapshots(cmd)

# Provides btrfs specific attributes that is required to clean btrfs snapshots
class BtrfsManager(FSManager):
    def __init__(self):
        super().__init__()
        self.top_level = ""
        self.snapshots_dir = ""

    def slicer(self, a_snap):
        # Split so that we can find the date part easier
        at_split = a_snap.split("/")

        # Splits the date part into month/date/year
        date_split = at_split[2].split("_")

        super().slicer(a_snap, at_split, date_split)

    def destroy(self, a_snap):
        snapshot_to_remove = self.top_level + "/" + a_snap
        cmd = 'btrfs subvol del ' + snapshot_to_remove
        super().destroy(a_snap, cmd)

    def destroy_snapshots(self):
        super().destroy_snapshots()

        # Remove the empty folders
        self.remove_empty_folders()

    # Remove all empty folders (dirty solution)
    def remove_empty_folders(self):
        cmd = 'rmdir ' + self.snapshots_dir + '/* 2> /dev/null'
        call(cmd, shell=True)

    # Retrieves all the snapshots for the given pool
    def get_pool_snapshots(self):
        cmd = 'btrfs subvol list ' + self.snapshots_dir + ' -o | cut -d " " -f 9'
        super().get_pool_snapshots(cmd)

    # Extracts the required information from the -p flag
    def get_pool_info(self, pool):
        # Strip trailing / from end of 'pool' parameter path since we do some further
        # breakdowns later on to extract the correct paths from this single parameter.
        # Example: /mnt/toplevel/tank/ -> /mnt/toplevel/tank
        pool = pool.rstrip("/")

        self.pool = os.path.basename(pool)
        self.top_level = os.path.dirname(pool)
        self.snapshots_dir = self.top_level + "/" + self.pool + "/snapshots"

        if not self.pool:
            Tools.die("There was an error retrieving the pool name from the path specified.")

        #self.print_pool_info()

    def print_pool_info(self):
        print("Pool: " + self.pool)
        print("Top Level: " + self.top_level)
        print("Snapshots Dir: " + self.snapshots_dir)

if __name__ == "__main__":
    cleaner = Cleaner()
    cleaner.welcome()
    cleaner.start()
